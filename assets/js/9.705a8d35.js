(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{289:function(t,e,n){t.exports=n.p+"assets/img/event-loop.d9fa44ce.png"},290:function(t,e,n){t.exports=n.p+"assets/img/mult-async.d7ffcdfd.png"},322:function(t,e,n){"use strict";n.r(e);var r=n(4),o=Object(r.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"事件循环"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事件循环"}},[t._v("#")]),t._v(" 事件循环")]),t._v(" "),e("p",[t._v("  我们知道node的行为是事件驱动，且非阻塞I/O模型，但是据我们所知，JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。要实现异步操作，这就依赖libuv提供的事件循环(Event Loop)机制。\n"),e("br"),t._v("\n如果想要了解更多关于事件轮询细节，可以阅读Mixu的博文——")]),t._v(" "),e("blockquote",[e("p",[e("a",{attrs:{href:"http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop/",target:"_blank",rel:"noopener noreferrer"}},[t._v("理解node.js的事件轮询"),e("OutboundLink")],1),t._v("。")])]),t._v(" "),e("h2",{attrs:{id:"单线程模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#单线程模式"}},[t._v("#")]),t._v(" 单线程模式")]),t._v(" "),e("p",[t._v("  单线程最大的特点就是："),e("code",[t._v("同一时间只能做一件事情")]),t._v(" "),e("br"),t._v("\n  意味着所有事情都要排队，只有当前面的工作完成之后，才能轮到下一个，这种队列形式的工作模式，如果前一个工作耗时很长，会导致队列后续的任务不得不等待。这是单线程带来的缺点，那么它有没有属于它的优点呢？答案是肯定的，单线程不用像多线程那样处在意状态的同步问题，也没有线程上下文交换所带来的性能上的开销。\n"),e("br"),t._v("\n  既然如此，那么node是如何实现非阻塞的异步操作的呢？这就是我们下面需要介绍的主角：Event Loop！")]),t._v(" "),e("h2",{attrs:{id:"event-loop"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#event-loop"}},[t._v("#")]),t._v(" Event Loop")]),t._v(" "),e("p",[t._v("  nodejs中，每个函数都是异步的，得益于有这个c/c++编写的Libuv库，通过它来实现的事件循环来实现这些耗时(相较于cpu处理速度)的I/O操作，简化并发编程模型，让你可以轻松的编写高性能的Web应用，所以它是轻量（lightweight）且高效（efficient）的，而且是兼容多平台的。\n"),e("br"),t._v("\n  在代码执行的过程中，遇到异步调用，由 Event Loop 来接受处理，而真正执行操作的是具体的线程池里的 I/O 任务。在进程启动时，Node便会创建一个类似于while(true)的循环，一次循环体称为Tick。每个Tick的过程就是查看是否有事件待处理，如果有，就取出事件及其相关的回调函数。如果存在关联的回调函数，就执行它们。然后进入下个循环，如果不再有事件处理，就退出进程。这一点与浏览器处理异步请求的方式类似！")]),t._v(" "),e("p",[e("img",{attrs:{src:n(289),alt:"Event Loop!",title:"Event Loop"}}),t._v(" "),e("center",[t._v("图片来自书籍《深入浅出nodejs》")])],1),t._v(" "),e("h2",{attrs:{id:"thread-pool-线程池"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#thread-pool-线程池"}},[t._v("#")]),t._v(" Thread Pool 线程池")]),t._v(" "),e("p",[t._v("Event Loop有提要一个新的知识点：线程池。什么是线程池呢？我们要理解传统的多线程异步I/O实现方式，借用下图：")]),t._v(" "),e("p",[e("img",{attrs:{src:n(290),alt:"mult-async!",title:"mult-async"}}),t._v(" "),e("center",[t._v("图片来自书籍《深入浅出nodejs》")])],1),t._v(" "),e("p",[t._v("  当遇到阻塞I/O时，这时会通过让部分线程进行阻塞I/O或者非阻塞I/O加轮询技术来完成数据获取，让一个线程进行计算处理，通过线程之间的通信将I/O得到的数据进行传递，这就轻松实现了异步I/O。\n"),e("br"),t._v("\n  我们知道nodejs的执行场景是限定了单线程，异步I/O会通过 Event Loop 分配给线程池，在线程池中会分发线程单独处理，主线程通过while(true)的循环，判断线程池中是否有回调(完成I/O)。这么看来跟多线程处理方式有什么区别呢？区别在于线程池是由系统内部控制的，不需要手动管理(什么意思？其实我也没特别搞明白。。。)。")]),t._v(" "),e("h2",{attrs:{id:"能做什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#能做什么"}},[t._v("#")]),t._v(" 能做什么？")]),t._v(" "),e("p",[t._v("适合做：I/O密集型业务，如：web；\n"),e("br"),t._v("\n不擅长：CPU密集型业务；")]),t._v(" "),e("h2",{attrs:{id:"参考资料"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),e("p",[e("a",{attrs:{href:"http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop/",target:"_blank",rel:"noopener noreferrer"}},[t._v("理解node.js的事件轮询"),e("OutboundLink")],1),t._v("。\n"),e("br"),t._v(" "),e("a",{attrs:{href:"https://book.douban.com/subject/25768396/",target:"_blank",rel:"noopener noreferrer"}},[t._v("深入浅出nodejs"),e("OutboundLink")],1),t._v("。")])])}),[],!1,null,null,null);e.default=o.exports}}]);